"""
This type stub file was generated by pyright.
"""

import collections
import compileall
import contextlib
import csv
import importlib
import logging
import os.path
import re
import shutil
import sys
import textwrap
import warnings
from base64 import urlsafe_b64encode
from collections.abc import Generator, Iterable, Iterator, Sequence
from email.message import Message
from itertools import chain, filterfalse, starmap
from typing import Any, BinaryIO, Callable, IO, NewType, Protocol, Union, cast
from zipfile import ZipFile, ZipInfo
from pip._vendor.distlib.scripts import ScriptMaker
from pip._vendor.distlib.util import get_export_entry
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.exceptions import InstallationError
from pip._internal.locations import get_major_minor_version
from pip._internal.metadata import BaseDistribution, FilesystemWheel, get_wheel_distribution
from pip._internal.models.direct_url import DIRECT_URL_METADATA_NAME, DirectUrl
from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.filesystem import adjacent_tmp_file, replace
from pip._internal.utils.misc import StreamWrapper, ensure_dir, hash_file, partition
from pip._internal.utils.unpacking import current_umask, is_within_directory, set_extracted_file_to_default_mode_plus_executable, zip_item_is_executable
from pip._internal.utils.wheel import parse_wheel

"""Support for installing and building the "wheel" binary package format."""
class File(Protocol):
    src_record_path: RecordPath
    dest_path: str
    changed: bool
    def save(self) -> None:
        ...
    


logger = ...
RecordPath = NewType("RecordPath", str)
InstalledCSVRow = tuple[RecordPath, str, Union[int, str]]
def rehash(path: str, blocksize: int = ...) -> tuple[str, str]:
    """Return (encoded_digest, length) for path using hashlib.sha256()"""
    ...

def csv_io_kwargs(mode: str) -> dict[str, Any]:
    """Return keyword arguments to properly open a CSV file
    in the given mode.
    """
    ...

def fix_script(path: str) -> bool:
    """Replace #!python with #!/path/to/python
    Return True if file was changed.
    """
    ...

def wheel_root_is_purelib(metadata: Message) -> bool:
    ...

def get_entrypoints(dist: BaseDistribution) -> tuple[dict[str, str], dict[str, str]]:
    ...

def message_about_scripts_not_on_PATH(scripts: Sequence[str]) -> str | None:
    """Determine if any scripts are not on PATH and format a warning.
    Returns a warning message if one or more scripts are not on PATH,
    otherwise None.
    """
    ...

def get_csv_rows_for_installed(old_csv_rows: list[list[str]], installed: dict[RecordPath, RecordPath], changed: set[RecordPath], generated: list[str], lib_dir: str) -> list[InstalledCSVRow]:
    """
    :param installed: A map from archive RECORD path to installation RECORD
        path.
    """
    ...

def get_console_script_specs(console: dict[str, str]) -> list[str]:
    """
    Given the mapping from entrypoint name to callable, return the relevant
    console script specs.
    """
    ...

class ZipBackedFile:
    def __init__(self, src_record_path: RecordPath, dest_path: str, zip_file: ZipFile) -> None:
        ...
    
    def save(self) -> None:
        ...
    


class ScriptFile:
    def __init__(self, file: File) -> None:
        ...
    
    def save(self) -> None:
        ...
    


class MissingCallableSuffix(InstallationError):
    def __init__(self, entry_point: str) -> None:
        ...
    


class PipScriptMaker(ScriptMaker):
    script_template = ...
    def make(self, specification: str, options: dict[str, Any] | None = ...) -> list[str]:
        ...
    


@contextlib.contextmanager
def req_error_context(req_description: str) -> Generator[None, None, None]:
    ...

def install_wheel(name: str, wheel_path: str, scheme: Scheme, req_description: str, pycompile: bool = ..., warn_script_location: bool = ..., direct_url: DirectUrl | None = ..., requested: bool = ...) -> None:
    ...

